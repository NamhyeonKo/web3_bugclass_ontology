# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

시간의 프록시로서의 블록 값

## 관계

- [CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)
  - [**[M] Document Special Code Use**](https://entethalliance.org/specs/ethtrust-sl/#req-2-documented)
  - [**[M] Don't Misuse Block Data**](https://entethalliance.org/specs/ethtrust-sl/#req-2-block-data-misuse)

## 설명

컨트랙트는 특정 유형의 기능을 수행하기 위해 종종 시간 값에 대한 액세스가 필요합니다. `block.timestamp` 및 `block.number`와 같은 값은 현재 시간이나 시간 델타를 파악할 수 있지만 대부분의 목적에는 사용하기에 안전하지 않습니다.

`block.timestamp`의 경우 개발자는 종종 시간 종속 이벤트를 트리거하기 위해 이를 사용하려고 시도합니다. 이더리움은 분산화되어 있으므로 노드는 어느 정도만 시간을 동기화할 수 있습니다. 더욱이 악의적인 채굴자는 특히 그렇게 함으로써 이득을 얻을 수 있는 경우 블록의 타임스탬프를 변경할 수 있습니다. 그러나 채굴자는 타임스탬프를 이전 타임스탬프보다 작게 설정할 수 없으며(그렇지 않으면 블록이 거부됨), 미래의 너무 먼 타임스탬프를 설정할 수도 없습니다. 위의 모든 사항을 고려할 때 개발자는 제공된 타임스탬프의 정확성에 의존할 수 없습니다.

`block.number`의 경우 이더리움의 블록 시간이 일반적으로 약 14초임을 고려하면 블록 간의 시간 델타를 예측할 수 있습니다. 그러나 블록 시간은 일정하지 않으며 포크 재구성 및 난이도 폭탄 등 다양한 이유로 변경될 수 있습니다. 가변 블록 시간으로 인해 `block.number`도 정확한 시간 계산에 의존해서는 안 됩니다.

## 해결방법

개발자는 블록 값이 정확하지 않다는 개념으로 스마트 컨트랙트를 작성해야 하며, 이를 사용하면 예상치 못한 효과로 이어질 수 있습니다. 또는 오라클을 사용할 수 있습니다.

## 참고자료

- [Safety: Timestamp dependence](https://github.com/ethereum/wiki/wiki/Safety#timestamp-dependence)
- [Ethereum Smart Contract Best Practices - Timestamp Dependence](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/)
- [How do Ethereum mining nodes maintain a time consistent with the network?](https://ethereum.stackexchange.com/questions/5924/how-do-ethereum-mining-nodes-maintain-a-time-consistent-with-the-network/5926#5926)
- [Solidity: Timestamp dependency, is it possible to do safely?](https://ethereum.stackexchange.com/questions/15047/solidity-timestamp-dependency-is-it-possible-to-do-safely)
- [Avoid using block.number as a timestamp](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/#avoid-using-blocknumber-as-a-timestamp)

## 샘플

### time_lock.sol

```solidity
/*
 * @author: Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract TimeLock {
    struct User {
        uint amount; // amount locked (in eth)
        uint unlockBlock; // minimum block to unlock eth
    }

    mapping(address => User) private users;

    // Tokens should be locked for exact time specified
    function lockEth(uint _time, uint _amount) public payable {
        require(msg.value == _amount, 'must send exact amount');
        users[msg.sender].unlockBlock = block.number + (_time / 14);
        users[msg.sender].amount = _amount;
    }

    // Withdraw tokens if lock period is over
    function withdraw() public {
        require(users[msg.sender].amount > 0, 'no amount locked');
        require(block.number >= users[msg.sender].unlockBlock, 'lock period not over');

        uint amount = users[msg.sender].amount;
        users[msg.sender].amount = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success, 'transfer failed');
    }
}

```

### timed_crowdsale.sol

```solidity
pragma solidity ^0.5.0;

contract TimedCrowdsale {

  event Finished();
  event notFinished();

  // Sale should finish exactly at January 1, 2019
  function isSaleFinished() private returns (bool) {
    return block.timestamp >= 1546300800;
  }

  function run() public {
  	if (isSaleFinished()) {
  		emit Finished();
  	} else {
  		emit notFinished();
  	}
  }

}
```
