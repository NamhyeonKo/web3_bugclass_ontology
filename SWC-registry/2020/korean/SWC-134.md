# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

하드코딩된 가스양을 사용한 메시지 호출

## 관계

[CWE-655: Improper Initialization](https://cwe.mitre.org/data/definitions/665.html)

## 설명

`transfer()` 및 `send()` 함수는 고정된 양의 2300 가스를 전달합니다. 역사적으로 재진입 공격(reentrancy attacks)을 방어하기 위해 값 전송에 이러한 함수를 사용하는 것이 자주 권장되었습니다. 그러나 EVM 명령의 가스 비용은 하드 포크 동안 크게 변경될 수 있으며, 이는 가스 비용에 대한 고정된 가정을 하는 이미 배포된 컨트랙트 시스템을 중단시킬 수 있습니다. 예를 들어, [EIP 1884](https://eips.ethereum.org/EIPS/eip-1884)는 SLOAD 명령의 비용 증가로 인해 여러 기존 스마트 컨트랙트를 중단시켰습니다.

## 해결방법

`transfer()` 및 `send()`의 사용을 피하고 호출을 수행할 때 고정된 가스 양을 지정하지 마십시오. 대신 `.call.value(...)("")`를 사용하십시오. checks-effects-interactions 패턴 및/또는 재진입 잠금을 사용하여 재진입 공격을 방지하십시오.

## 참고자료

- [ChainSecurity - Ethereum Istanbul Hardfork: The Security Perspective](https://docs.google.com/presentation/d/1IiRYSjwle02zQUmWId06Bss8GrxGyw6nQAiZdCRFEPk/)
- [Steve Marx - Stop Using Solidity's transfer() Now
  ](https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/)
- [EIP 1884](https://eips.ethereum.org/EIPS/eip-1884)

## 샘플

### hardcoded_gas_limits.sol

```solidity
/*
 * @author: Bernhard Mueller (ConsenSys / MythX)
 */

pragma solidity 0.6.4;

interface ICallable {
	function callMe() external;
}

contract HardcodedNotGood {

    address payable _callable = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;
	ICallable callable = ICallable(_callable);

	constructor() public payable {
	}

    function doTransfer(uint256 amount) public {
        _callable.transfer(amount);
    }

    function doSend(uint256 amount) public {
    	_callable.send(amount);
    }

     function callLowLevel() public {
         _callable.call.value(0).gas(10000)("");
     }

     function callWithArgs() public {
         callable.callMe{gas: 10000}();
     }
}

```
