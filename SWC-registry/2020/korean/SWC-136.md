# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

온체인 상의 암호화되지 않은 개인 데이터

## 관계

- [CWE-767: Access to Critical Private Variable via Public Method](https://cwe.mitre.org/data/definitions/767.html)
- EthTrust Security Levels:
  - [**[Q] No Private Data**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-3-no-private-data)
  - [**[Q] Enforce Least Privilege**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-3-access-control)

## 설명

`private` 타입 변수를 읽을 수 없다는 것은 일반적인 오해입니다. 컨트랙트가 공개되지 않더라도 공격자는 컨트랙트 트랜잭션을 살펴봄으로써 컨트랙트의 상태에 저장된 값을 확인할 수 있습니다. 이러한 이유로 암호화되지 않은 개인 데이터를 컨트랙트 코드나 상태에 저장하지 않는 것이 중요합니다.

## 해결방법

모든 개인 데이터는 오프체인에 저장되거나 신중하게 암호화되어야 합니다.

## 참고자료

- [Keeping secrets on Ethereum](https://medium.com/solidified/keeping-secrets-on-ethereum-5b556c3bb1ee)
- [A Survey of Attacks on Ethereum Smart Contracts (SoK)](https://www.semanticscholar.org/paper/A-Survey-of-Attacks-on-Ethereum-Smart-Contracts-Atzei-Bartoletti/aec843c0f38aff6c7901391a75ec10114a3d60f8)
- [Unencrypted Secrets](https://github.com/KadenZipfel/smart-contract-attack-vectors/blob/master/vulnerabilities/unencrypted-secrets.md)
- [Stack Overflow - Decrypt message on-chain](https://ethereum.stackexchange.com/questions/69825/decrypt-message-on-chain)

## 샘플

### odd_even.sol

```solidity
/*
 * @source: https://gist.github.com/manojpramesh/336882804402bee8d6b99bea453caadd#file-odd-even-sol
 * @author: https://github.com/manojpramesh
 * Modified by Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract OddEven {
    struct Player {
        address addr;
        uint number;
    }

    Player[2] private players;
    uint count = 0;

    function play(uint number) public payable {
            require(msg.value == 1 ether, 'msg.value must be 1 eth');
            players[count] = Player(msg.sender, number);
            count++;
            if (count == 2) selectWinner();
    }

    function selectWinner() private {
            uint n = players[0].number + players[1].number;
            (bool success, ) = players[n%2].addr.call.value(address(this).balance)("");
            require(success, 'transfer failed');
            delete players;
            count = 0;
    }
}
```

#### 코멘트

위의 취약한 버전은 플레이어가 트랜잭션의 일부로 사용하는 숫자를 보내도록 요구합니다.
이는 첫 번째 플레이어의 숫자가 보이게 되어, 두 번째 플레이어가 자신을 승자로 만들 숫자를 선택할 수 있게 합니다.
(이 가정은 설명을 위해 단순화된 것입니다 - 프런트런 플레이어 등 다른 잠재적인 문제도 있습니다).

아래의 수정된 버전에서는 플레이어가 대신 자신의 숫자를 난독화하는 약속(commitment)을 제출하고,
나중에 비밀을 알고 있음을 밝혀야만 지불 프로세스가 시작됩니다.

### odd_even_fixed.sol

```solidity
/*
 * @source: https://github.com/yahgwai/rps
 * @author: Chris Buckland
 * Modified by Kaden Zipfel
 * Modified by Kacper Żuk
 */

pragma solidity ^0.5.0;

contract OddEven {
    enum Stage {
        FirstCommit,
        SecondCommit,
        FirstReveal,
        SecondReveal,
        Distribution
    }

    struct Player {
        address addr;
        bytes32 commitment;
        bool revealed;
        uint number;
    }

    Player[2] private players;
    Stage public stage = Stage.FirstCommit;

    function play(bytes32 commitment) public payable {
        // Only run during commit stages
        uint playerIndex;
        if(stage == Stage.FirstCommit) playerIndex = 0;
        else if(stage == Stage.SecondCommit) playerIndex = 1;
        else revert("only two players allowed");

        // Require proper amount deposited
        // 1 ETH as a bet + 1 ETH as a bond
        require(msg.value == 2 ether, 'msg.value must be 2 eth');

        // Store the commitment
        players[playerIndex] = Player(msg.sender, commitment, false, 0);

        // Move to next stage
        if(stage == Stage.FirstCommit) stage = Stage.SecondCommit;
        else stage = Stage.FirstReveal;
    }

    function reveal(uint number, bytes32 blindingFactor) public {
        // Only run during reveal stages
        require(stage == Stage.FirstReveal || stage == Stage.SecondReveal, "wrong stage");

        // Find the player index
        uint playerIndex;
        if(players[0].addr == msg.sender) playerIndex = 0;
        else if(players[1].addr == msg.sender) playerIndex = 1;
        else revert("unknown player");

        // Protect against double-reveal, which would trigger move to Stage.Distribution too early
        require(!players[playerIndex].revealed, "already revealed");

        // Check the hash to prove the player's honesty
        require(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, "invalid hash");

        // Update player number if correct
        players[playerIndex].number = number;

        // Protect against double-reveal
        players[playerIndex].revealed = true;

        // Move to next stage
        if(stage == Stage.FirstReveal) stage = Stage.SecondReveal;
        else stage = Stage.Distribution;
    }

    function distribute() public {
        // Only run during distribution stage
        require(stage == Stage.Distribution, "wrong stage");

        // Find winner
        uint n = players[0].number + players[1].number;

        // Payout winners winnings and bond
        players[n%2].addr.call.value(3 ether)("");

        // Payback losers bond
        players[(n+1)%2].addr.call.value(1 ether)("");

        // Reset the state
        delete players;
        stage = Stage.FirstCommit;
    }
}

```
