# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

트랜잭션 순서 의존성

## 관계

[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)

## 설명

이더리움 네트워크는 블록 단위로 트랜잭션을 처리하며, 약 17초마다 새로운 블록이 확인됩니다. 채굴자는 받은 트랜잭션을 검토하고 충분한 가스 가격을 지불한 사람에 따라 블록에 포함할 트랜잭션을 선택합니다. 또한 트랜잭션이 이더리움 네트워크로 전송되면 처리를 위해 각 노드로 전달됩니다. 따라서 이더리움 노드를 실행하는 사람은 트랜잭션이 최종화되기 전에 어떤 트랜잭션이 발생할지 알 수 있습니다. 레이스 컨디션 취약점은 코드가 제출된 트랜잭션의 순서에 의존할 때 발생합니다.

레이스 컨디션의 가장 간단한 예는 스마트 컨트랙트가 정보 제출에 대한 보상을 제공할 때입니다. 컨트랙트가 수학 문제를 해결한 첫 번째 사람에게 1 토큰을 제공한다고 가정합니다. Alice는 문제를 해결하고 표준 가스 가격으로 네트워크에 답을 제출합니다. Eve는 이더리움 노드를 실행하며 Alice가 네트워크에 제출한 트랜잭션에서 수학 문제의 답을 볼 수 있습니다. 따라서 Eve는 훨씬 더 높은 가스 가격으로 네트워크에 답을 제출하므로 Alice의 트랜잭션보다 먼저 처리되고 커밋됩니다. Eve는 1 토큰을 받고 Alice는 아무것도 받지 못합니다. 문제를 해결한 것은 Alice였는데도 말입니다. 이는 실제로 프로토콜에서 나쁜 행동을 지적하여 나쁜 행위자의 예치금을 증명한 사람에게 주는 컨트랙트가 사람들에게 보상을 제공할 때 자주 발생합니다.

오늘날 네트워크에서 가장 자주 발생하는 레이스 컨디션은 ERC20 토큰 표준의 레이스 컨디션입니다. ERC20 토큰 표준에는 'approve'라는 함수가 포함되어 있으며, 이는 주소가 다른 주소에게 대신 토큰을 사용하도록 승인할 수 있게 합니다. Alice가 Eve에게 n개의 토큰을 사용하도록 승인했다가 Alice가 Eve의 승인을 m개의 토큰으로 변경하기로 결정했다고 가정합니다. Alice는 Eve에 대한 값 n으로 approve 함수 호출을 제출합니다. Eve는 이더리움 노드를 실행하므로 Alice가 승인을 m으로 변경할 것임을 알고 있습니다. Eve는 n개의 Alice의 토큰을 자신에게 보내는 transferFrom 요청을 제출하지만 Alice의 트랜잭션보다 훨씬 더 높은 가스 가격을 제공합니다. transferFrom이 먼저 실행되어 Eve에게 n개의 토큰을 제공하고 Eve의 승인을 0으로 설정합니다. 그런 다음 Alice의 트랜잭션이 실행되어 Eve의 승인을 m으로 설정합니다. Eve는 그 m개의 토큰도 자신에게 보냅니다. 따라서 Eve는 최대 max(n,m)개를 받아야 함에도 n + m개의 토큰을 받습니다.

## 해결방법

보상을 위한 정보 제출에서 레이스 컨디션을 해결하는 가능한 방법은 커밋 리빌 해시 스킴이라고 합니다. 답을 제출하는 대신 답을 가진 당사자는 hash(salt, address, answer)를 제출합니다 [salt는 선택한 일부 번호]; 컨트랙트는 이 해시와 발신자의 주소를 저장합니다. 보상을 청구하려면 발신자는 salt와 답을 포함한 트랜잭션을 제출합니다. 컨트랙트는 (salt, msg.sender, answer)를 해시하고 저장된 해시와 생성된 해시를 확인합니다. 해시가 일치하면 컨트랙트는 보상을 해제합니다.

ERC20 레이스 컨디션에 대한 최선의 수정은 예상되는 현재 값인 approve의 입력에 필드를 추가하고 Eve의 현재 허용량이 Alice가 예상한 것과 다를 경우 approve가 되돌아가도록 하는 것입니다. 그러나 이는 컨트랙트가 더 이상 ERC20 표준을 준수하지 않음을 의미합니다. 컨트랙트가 ERC20를 준수하는 것이 프로젝트에 중요한 경우 안전한 approve 함수를 추가할 수 있습니다. 사용자의 관점에서 승인을 변경하기 전에 승인을 0으로 설정하여 ERC20 레이스 컨디션을 완화할 수 있습니다.

## 참고자료

[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)
[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)

## 샘플

### ERC20.sol

```solidity
pragma solidity ^0.4.24;

/** Taken from the OpenZeppelin github
 * @title SafeMath
 * @dev Math operations with safety checks that revert on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, reverts on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}


contract ERC20 {

  event Transfer( address indexed from, address indexed to, uint256 value );
  event Approval( address indexed owner, address indexed spender, uint256 value);
  using SafeMath for *;

  mapping (address => uint256) private _balances;

  mapping (address => mapping (address => uint256)) private _allowed;

  uint256 private _totalSupply;

  constructor(uint totalSupply){
    _balances[msg.sender] = totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }


  function allowance(address owner, address spender) public view returns (uint256)
  {
    return _allowed[owner][spender];
  }

  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  }

  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  }
}

```

### eth_tx_order_dependence_minimal.sol

```solidity
/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 */

pragma solidity ^0.4.16;

contract EthTxOrderDependenceMinimal {
    address public owner;
    bool public claimed;
    uint public reward;

    function EthTxOrderDependenceMinimal() public {
        owner = msg.sender;
    }

    function setReward() public payable {
        require (!claimed);

        require(msg.sender == owner);
        owner.transfer(reward);
        reward = msg.value;
    }

    function claimReward(uint256 submission) {
        require (!claimed);
        require(submission < 10);

        msg.sender.transfer(reward);
        claimed = true;
    }
}


```
