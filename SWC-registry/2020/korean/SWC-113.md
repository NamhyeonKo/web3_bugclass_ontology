# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

실패한 호출로 인한 DoS

## 관계

[CWE-703: Improper Check or Handling of Exceptional Conditions](https://cwe.mitre.org/data/definitions/703.html)

## 설명

외부 호출은 실수로 또는 의도적으로 실패할 수 있으며, 이는 컨트랙트에서 DoS 상태를 유발할 수 있습니다. 이러한 실패로 인한 피해를 최소화하려면 각 외부 호출을 호출 수신자가 시작할 수 있는 자체 트랜잭션으로 격리하는 것이 좋습니다. 이는 특히 지불에 관련된 경우 더욱 중요하며, 자금을 자동으로 푸시하는 대신 사용자가 자금을 인출하도록 하는 것이 좋습니다(이는 가스 한도 문제의 가능성도 줄입니다).

## 해결방법

호출 모범 사례를 따르는 것이 권장됩니다:

- 단일 트랜잭션에서 여러 호출을 결합하지 마십시오. 특히 호출이 루프의 일부로 실행되는 경우
- 항상 외부 호출이 실패할 수 있다고 가정하십시오
- 실패한 호출을 처리하도록 컨트랙트 로직을 구현하십시오

## 참고자료

- [Ethereum Smart Contract Best Practices - Favor pull over push for external calls](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls)

## 샘플

### send_loop.sol

```solidity
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert
 * @author: ConsenSys Diligence
 * Modified by Bernhard Mueller
 */

pragma solidity 0.4.24;

contract Refunder {

address[] private refundAddresses;
mapping (address => uint) public refunds;

	constructor() {
		refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);
		refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);
	}

	// bad
	function refundAll() public {
	    for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
	        require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
	    }
	}

}

```
