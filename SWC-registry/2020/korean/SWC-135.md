# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

효과가 없는 코드

## 관계

- [CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)
- EthTrust Security Levels:
  - [**[Q] Code Linting**](https://entethalliance.org/specs/ethtrust-sl/#req-3-linted)

## 설명

Solidity에서는 의도한 효과를 생성하지 않는 코드를 작성할 수 있습니다. 현재 Solidity 컴파일러는 효과 없는 코드에 대해 경고를 반환하지 않습니다. 이는 의도한 작업을 제대로 수행하지 않는 "데드" 코드의 도입으로 이어질 수 있습니다.

예를 들어, `msg.sender.call.value(address(this).balance)("");`의 뒤쪽 괄호를 놓치기 쉬우며, 이는 `msg.sender`에게 자금을 전송하지 않고 함수가 진행되도록 할 수 있습니다. 물론 이는 [호출의 반환 값을 확인](./SWC-104.md)하여 피해야 합니다.

## 해결방법

컨트랙트가 의도한 대로 작동하는지 신중하게 확인하는 것이 중요합니다. 코드의 올바른 동작을 검증하기 위해 단위 테스트를 작성하십시오.

## 참고자료

- [Issue on Solidity's Github - raise an error when a statement can never have side-effects](https://github.com/ethereum/solidity/issues/2707)
- [Issue on Solidity's Github - msg.sender.call.value(address(this).balance); should produce a warning](https://github.com/ethereum/solidity/issues/7096)

## 샘플

### deposit_box.sol

```solidity
pragma solidity ^0.5.0;

contract DepositBox {
    mapping(address => uint) balance;

    // Accept deposit
    function deposit(uint amount) public payable {
        require(msg.value == amount, 'incorrect amount');
        // Should update user balance
        balance[msg.sender] == amount;
    }
}
```

### deposit_box_fixed.sol

```solidity
pragma solidity ^0.5.0;

contract DepositBox {
    mapping(address => uint) balance;

    // Accept deposit
    function deposit(uint amount) public payable {
        require(msg.value == amount, 'incorrect amount');
        // Should update user balance
        balance[msg.sender] = amount;
    }
}
```

### wallet.sol

```solidity
/*
 * @author: Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract Wallet {
    mapping(address => uint) balance;

    // Deposit funds in contract
    function deposit(uint amount) public payable {
        require(msg.value == amount, 'msg.value must be equal to amount');
        balance[msg.sender] = amount;
    }

    // Withdraw funds from contract
    function withdraw(uint amount) public {
        require(amount <= balance[msg.sender], 'amount must be less than balance');

        uint previousBalance = balance[msg.sender];
        balance[msg.sender] = previousBalance - amount;

        // Attempt to send amount from the contract to msg.sender
        msg.sender.call.value(amount);
    }
}
```

### wallet_fixed.sol

```solidity
/*
 * @author: Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract Wallet {
    mapping(address => uint) balance;

    // Deposit funds in contract
    function deposit(uint amount) public payable {
        require(msg.value == amount, 'msg.value must be equal to amount');
        balance[msg.sender] = amount;
    }

    // Withdraw funds from contract
    function withdraw(uint amount) public {
        require(amount <= balance[msg.sender], 'amount must be less than balance');

        uint previousBalance = balance[msg.sender];
        balance[msg.sender] = previousBalance - amount;

        // Attempt to send amount from the contract to msg.sender
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success, 'transfer failed');
    }
}
```
