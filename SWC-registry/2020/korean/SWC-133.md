# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

여러 가변 길이 인수를 사용한 해시 충돌

## 관계

[CWE-294: Authentication Bypass by Capture-replay](https://cwe.mitre.org/data/definitions/294.html)

## 설명

여러 가변 길이 인수와 함께 `abi.encodePacked()`를 사용하면 특정 상황에서 해시 충돌이 발생할 수 있습니다. `abi.encodePacked()`는 배열의 일부인지 여부에 관계없이 모든 요소를 순서대로 패킹하기 때문에, 모든 요소가 동일한 순서에 있는 한 배열 간에 요소를 이동하여 동일한 인코딩을 반환할 수 있습니다. 서명 검증 상황에서 공격자는 이전 함수 호출에서 요소의 위치를 수정하여 효과적으로 인증을 우회할 수 있습니다.

## 해결방법

`abi.encodePacked()`를 사용할 때는 다른 매개변수를 사용하여 일치하는 서명을 얻을 수 없도록 하는 것이 중요합니다. 이를 위해 `abi.encodePacked()`에 사용되는 매개변수에 대한 사용자 액세스를 허용하지 않거나 고정 길이 배열을 사용하십시오. 또는 단순히 `abi.encode()`를 대신 사용할 수 있습니다.

또한 재생 보호(replay protection)를 사용하는 것이 권장됩니다([SWC-121](./SWC-121.md) 참조). 하지만 공격자는 여전히 [프런트러닝](./SWC-114.md)을 통해 이를 우회할 수 있습니다.

## 참고자료

- [Solidity Non-standard Packed Mode](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html#non-standard-packed-mode)
- [Hash Collision Attack](https://learncryptography.com/hash-functions/hash-collision-attack)

## 샘플

### access_control.sol

```solidity
/*
 * @author: Steve Marx
 */

pragma solidity ^0.5.0;

import "./ECDSA.sol";

contract AccessControl {
    using ECDSA for bytes32;
    mapping(address => bool) isAdmin;
    mapping(address => bool) isRegularUser;
    // Add admins and regular users.
    function addUsers(
        address[] calldata admins,
        address[] calldata regularUsers,
        bytes calldata signature
    )
        external
    {
        if (!isAdmin[msg.sender]) {
            // Allow calls to be relayed with an admin's signature.
            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));
            address signer = hash.toEthSignedMessageHash().recover(signature);
            require(isAdmin[signer], "Only admins can add users.");
        }
        for (uint256 i = 0; i < admins.length; i++) {
            isAdmin[admins[i]] = true;
        }
        for (uint256 i = 0; i < regularUsers.length; i++) {
            isRegularUser[regularUsers[i]] = true;
        }
    }
}
```

### access_control_fixed_1.sol

```solidity
/*
 * @author: Steve Marx
 * Modified by Kaden Zipfel
 */

pragma solidity ^0.5.0;

import "./ECDSA.sol";

contract AccessControl {
    using ECDSA for bytes32;
    mapping(address => bool) isAdmin;
    mapping(address => bool) isRegularUser;
    // Add a single user, either an admin or regular user.
    function addUser(
        address user,
        bool admin,
        bytes calldata signature
    )
        external
    {
        if (!isAdmin[msg.sender]) {
            // Allow calls to be relayed with an admin's signature.
            bytes32 hash = keccak256(abi.encodePacked(user));
            address signer = hash.toEthSignedMessageHash().recover(signature);
            require(isAdmin[signer], "Only admins can add users.");
        }
        if (admin) {
            isAdmin[user] = true;
        } else {
            isRegularUser[user] = true;
        }
    }
}
```

### access_control_fixed_2.sol

```solidity
/*
 * @author: Steve Marx
 * Modified by Kaden Zipfel
 */

pragma solidity ^0.5.0;

import "./ECDSA.sol";

contract AccessControl {
    using ECDSA for bytes32;
    mapping(address => bool) isAdmin;
    mapping(address => bool) isRegularUser;
    // Add admins and regular users.
    function addUsers(
        // Use fixed length arrays.
        address[3] calldata admins,
        address[3] calldata regularUsers,
        bytes calldata signature
    )
        external
    {
        if (!isAdmin[msg.sender]) {
            // Allow calls to be relayed with an admin's signature.
            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));
            address signer = hash.toEthSignedMessageHash().recover(signature);
            require(isAdmin[signer], "Only admins can add users.");
        }
        for (uint256 i = 0; i < admins.length; i++) {
            isAdmin[admins[i]] = true;
        }
        for (uint256 i = 0; i < regularUsers.length; i++) {
            isRegularUser[regularUsers[i]] = true;
        }
    }
}
```
