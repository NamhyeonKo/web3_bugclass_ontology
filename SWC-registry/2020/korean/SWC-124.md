# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

임의의 스토리지 위치에 쓰기

## 관계

[CWE-123: Write-what-where Condition](https://cwe.mitre.org/data/definitions/123.html)

## 설명

스마트 컨트랙트의 데이터(예: 컨트랙트의 소유자 저장)는 EVM 레벨에서 일부 스토리지 위치(즉, 키 또는 주소)에 지속적으로 저장됩니다. 컨트랙트는 승인된 사용자 또는 컨트랙트 계정만이 민감한 스토리지 위치에 쓸 수 있도록 보장해야 합니다. 공격자가 컨트랙트의 임의 스토리지 위치에 쓸 수 있는 경우, 권한 부여 검사는 쉽게 우회될 수 있습니다. 이를 통해 공격자는 스토리지를 손상시킬 수 있습니다. 예를 들어, 컨트랙트 소유자의 주소를 저장하는 필드를 덮어쓸 수 있습니다.

## 해결방법

일반적인 조언으로, 모든 데이터 구조가 동일한 스토리지(주소) 공간을 공유하므로, 하나의 데이터 구조에 대한 쓰기가 다른 데이터 구조의 항목을 실수로 덮어쓸 수 없도록 해야 합니다.

## 참고자료

- [Entry to Underhanded Solidity Coding Contest 2017 (honorable mention)](https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte)

## 샘플

### arbitrary_location_write_simple.sol

```solidity
pragma solidity ^0.4.25;

contract Wallet {
    uint[] private bonusCodes;
    address private owner;

    constructor() public {
        bonusCodes = new uint[](0);
        owner = msg.sender;
    }

    function () public payable {
    }

    function PushBonusCode(uint c) public {
        bonusCodes.push(c);
    }

    function PopBonusCode() public {
        require(0 <= bonusCodes.length);
        bonusCodes.length--;
    }

    function UpdateBonusCodeAt(uint idx, uint c) public {
        require(idx < bonusCodes.length);
        bonusCodes[idx] = c;
    }

    function Destroy() public {
        require(msg.sender == owner);
        selfdestruct(msg.sender);
    }
}

```

### arbitrary_location_write_simple_fixed.sol

```solidity
pragma solidity ^0.4.25;

contract Wallet {
    uint[] private bonusCodes;
    address private owner;

    constructor() public {
        bonusCodes = new uint[](0);
        owner = msg.sender;
    }

    function () public payable {
    }

    function PushBonusCode(uint c) public {
        bonusCodes.push(c);
    }

    function PopBonusCode() public {
        require(0 < bonusCodes.length);
        bonusCodes.length--;
    }

    function UpdateBonusCodeAt(uint idx, uint c) public {
        require(idx < bonusCodes.length); //Since you now have to push very codes this is no longer an arbitray write.
        bonusCodes[idx] = c;
    }

    function Destroy() public {
        require(msg.sender == owner);
        selfdestruct(msg.sender);
    }
}

```

### mapping_write.sol

```solidity
pragma solidity ^0.4.24;

//This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/

contract Map {
    address public owner;
    uint256[] map;

    function set(uint256 key, uint256 value) public {
        if (map.length <= key) {
            map.length = key + 1;
        }

        map[key] = value;
    }

    function get(uint256 key) public view returns (uint256) {
        return map[key];
    }
    function withdraw() public{
      require(msg.sender == owner);
      msg.sender.transfer(address(this).balance);
    }
}

```
