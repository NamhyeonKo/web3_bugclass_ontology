# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

신뢰할 수 없는 Callee로의 Delegatecall

## 관계

[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)

## 설명

`delegatecall`이라는 특수한 메시지 호출 변형이 있습니다. 이는 대상 주소의 코드가 호출 컨트랙트의 컨텍스트에서 실행되고 `msg.sender`와 `msg.value`가 값을 변경하지 않는다는 점을 제외하면 메시지 호출과 동일합니다. 이를 통해 스마트 컨트랙트는 런타임에 다른 주소에서 코드를 동적으로 로드할 수 있습니다. 스토리지, 현재 주소 및 잔액은 여전히 호출 컨트랙트를 참조합니다.

신뢰할 수 없는 컨트랙트로 호출하는 것은 매우 위험합니다. 대상 주소의 코드는 호출자의 모든 스토리지 값을 변경할 수 있으며 호출자의 잔액을 완전히 제어할 수 있기 때문입니다.

## 해결방법

`delegatecall`을 주의해서 사용하고 신뢰할 수 없는 컨트랙트로 절대 호출하지 마십시오. 대상 주소가 사용자 입력에서 파생된 경우 신뢰할 수 있는 컨트랙트의 화이트리스트와 대조하여 확인하십시오.

## 참고자료

- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)
- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)
- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)

## 샘플

### proxy.sol

```solidity
pragma solidity ^0.4.24;

contract Proxy {

  address owner;

  constructor() public {
    owner = msg.sender;
  }

  function forward(address callee, bytes _data) public {
    require(callee.delegatecall(_data));
  }

}

```

### proxy_fixed.sol

```solidity
pragma solidity ^0.4.24;

contract Proxy {

  address callee;
  address owner;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  constructor() public {
  	callee = address(0x0);
    owner = msg.sender;
  }

  function setCallee(address newCallee) public onlyOwner {
  	callee = newCallee;
  }

  function forward(bytes _data) public {
    require(callee.delegatecall(_data));
  }

}

```

### proxy_pattern_false_positive.sol

```solidity
pragma solidity ^0.4.24;

contract proxy{
  address owner;

  function proxyCall(address _to, bytes _data) external {
    require( !_to.delegatecall(_data));
  }
  function withdraw() external{
    require(msg.sender == owner);
    msg.sender.transfer(address(this).balance);
  }
}

/*
You can't use proxyCall to change the owner address as either:

1) the delegatecall reverts and thus does not change owner
2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing

This false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures
*/
```
