# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

재진입(Reentrancy)

## 관계

[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)

## 설명

외부 컨트랙트를 호출할 때의 주요 위험 중 하나는 해당 컨트랙트가 제어 흐름을 장악할 수 있다는 것입니다. 재진입 공격(재귀 호출 공격이라고도 함)에서 악의적인 컨트랙트는 함수의 첫 번째 호출이 완료되기 전에 호출 컨트랙트를 다시 호출합니다. 이로 인해 함수의 다른 호출이 바람직하지 않은 방식으로 상호작용할 수 있습니다.

## 해결방법

재진입 취약점을 방지하기 위한 모범 사례는 다음과 같습니다:

- 호출이 실행되기 전에 모든 내부 상태 변경이 수행되도록 하십시오. 이는 [Checks-Effects-Interactions 패턴](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern)으로 알려져 있습니다.
- 재진입 잠금 장치를 사용하십시오(예: [OpenZeppelin의 ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)).

## 참고자료

- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/)

## 샘플

### modifier_reentrancy.sol

```solidity
pragma solidity ^0.5.0;

contract ModifierEntrancy {

  mapping (address => uint) public tokenBalance;
  string constant name = "Nu Token";
  Bank bank;

  constructor() public{
      bank = new Bank();
  }

  //If a contract has a zero balance and supports the token give them some token
  function airDrop() hasNoBalance supportsToken  public{
    tokenBalance[msg.sender] += 20;
  }

  //Checks that the contract responds the way we want
  modifier supportsToken() {
    require(keccak256(abi.encodePacked("Nu Token")) == bank.supportsToken());
    _;
  }

  //Checks that the caller has a zero balance
  modifier hasNoBalance {
      require(tokenBalance[msg.sender] == 0);
      _;
  }
}

contract Bank{

    function supportsToken() external returns(bytes32) {
        return keccak256(abi.encodePacked("Nu Token"));
    }

}

```

### modifier_reentrancy_fixed.sol

```solidity
pragma solidity ^0.5.0;

contract ModifierEntrancy {
  mapping (address => uint) public tokenBalance;
  string constant name = "Nu Token";
  Bank bank;
  constructor() public{
      bank = new Bank();
  }

  //If a contract has a zero balance and supports the token give them some token
  function airDrop() supportsToken hasNoBalance  public{ // In the fixed version supportsToken comes before hasNoBalance
    tokenBalance[msg.sender] += 20;
  }

  //Checks that the contract responds the way we want
  modifier supportsToken() {
    require(keccak256(abi.encodePacked("Nu Token")) == bank.supportsToken());
    _;
  }
  //Checks that the caller has a zero balance
  modifier hasNoBalance {
      require(tokenBalance[msg.sender] == 0);
      _;
  }
}

contract Bank{

    function supportsToken() external returns(bytes32){
        return(keccak256(abi.encodePacked("Nu Token")));
    }
}

```

### simple_dao.sol

```solidity
/*
 * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao
 * @author: Atzei N., Bartoletti M., Cimoli T
 * Modified by Josselin Feist
 */
pragma solidity 0.4.24;

contract SimpleDAO {
  mapping (address => uint) public credit;

  function donate(address to) payable public{
    credit[to] += msg.value;
  }

  function withdraw(uint amount) public{
    if (credit[msg.sender]>= amount) {
      require(msg.sender.call.value(amount)());
      credit[msg.sender]-=amount;
    }
  }

  function queryCredit(address to) view public returns(uint){
    return credit[to];
  }
}

```

### simple_dao_fixed.sol

```solidity
/*
 * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao
 * @author: Atzei N., Bartoletti M., Cimoli T
 * Modified by Bernhard Mueller, Josselin Feist
 */
pragma solidity 0.4.24;

contract SimpleDAO {
  mapping (address => uint) public credit;

  function donate(address to) payable public{
    credit[to] += msg.value;
  }

  function withdraw(uint amount) public {
    if (credit[msg.sender]>= amount) {
      credit[msg.sender]-=amount;
      require(msg.sender.call.value(amount)());
    }
  }

  function queryCredit(address to) view public returns (uint){
    return credit[to];
  }
}

```
