# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

상태 변수 섀도잉

## 관계

- [CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)
- EthTrust Security Levels:
  - [**[Q] Implement as Documented**](https://entethalliance.org/specs/ethtrust-sl/#req-3-implement-as-documented)

## 설명

Solidity는 상속이 사용될 때 상태 변수의 모호한 이름 지정을 허용합니다. 변수 `x`를 가진 컨트랙트 `A`는 상태 변수 `x`도 정의된 컨트랙트 `B`를 상속할 수 있습니다. 이로 인해 `x`의 두 개의 별도 버전이 생기며, 하나는 컨트랙트 `A`에서 액세스되고 다른 하나는 컨트랙트 `B`에서 액세스됩니다. 더 복잡한 컨트랙트 시스템에서는 이 조건이 눈에 띄지 않을 수 있으며 결과적으로 보안 문제로 이어질 수 있습니다.

상태 변수 섀도잉은 컨트랙트 및 함수 수준에 여러 정의가 있을 때 단일 컨트랙트 내에서도 발생할 수 있습니다.

## 해결방법

컨트랙트 시스템의 스토리지 변수 레이아웃을 주의 깊게 검토하고 모호함을 제거하십시오. 항상 컴파일러 경고를 확인하십시오. 단일 컨트랙트 내에서 문제를 표시할 수 있습니다.

## 참고자료

- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)
- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)

EthTrust Security Levels:
  - [**[Q] Implement as Documented**](https://entethalliance.org/specs/ethtrust-sl/#req-3-implement-as-documented)

## 샘플

### ShadowingInFunctions.sol

```solidity
pragma solidity 0.4.24;

contract ShadowingInFunctions {
    uint n = 2;
    uint x = 3;

    function test1() constant returns (uint n) {
        return n; // Will return 0
    }

    function test2() constant returns (uint n) {
        n = 1;
        return n; // Will return 1
    }

    function test3() constant returns (uint x) {
        uint n = 4;
        return n+x; // Will return 4
    }
}

```

### TokenSale.sol

```solidity
pragma solidity 0.4.24;

contract Tokensale {
    uint hardcap = 10000 ether;

    function Tokensale() {}

    function fetchCap() public constant returns(uint) {
        return hardcap;
    }
}

contract Presale is Tokensale {
    uint hardcap = 1000 ether;

    function Presale() Tokensale() {}
}

```

### TokenSale_fixed.sol

```solidity
pragma solidity 0.4.25;

//We fix the problem by eliminating the declaration which overrides the prefered hardcap.

contract Tokensale {
    uint public hardcap = 10000 ether;

    function Tokensale() {}

    function fetchCap() public constant returns(uint) {
        return hardcap;
    }
}

contract Presale is Tokensale {
    //uint hardcap = 1000 ether;
    //If the hardcap variables were both needed we would have to rename one to fix this.
    function Presale() Tokensale() {
        hardcap = 1000 ether; //We set the hardcap from the constructor for the Tokensale to be 1000 instead of 10000
    }
}

```
