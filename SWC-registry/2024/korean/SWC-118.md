# 주의: 이 콘텐츠는 더 이상 적극적으로 유지관리되지 않습니다.

SWC 레지스트리의 콘텐츠는 2020년 이후로 철저하게 업데이트되지 않았습니다. 불완전한 것으로 알려져 있으며 오류와 중요한 누락이 포함될 수 있습니다.

보안 검토자를 위한 가이드로 작성된 알려진 스마트 컨트랙트 취약점에 대한 현재 유지관리되는 가이던스는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전뿐만 아니라
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공되며,
이는 사양을 개발하는 그룹의 최신 작업을 나타냅니다.

개발자가 보안을 보장하기 위해 고려해야 할 사항에 대한 현재 유지관리되는 일반 가이던스는
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

잘못된 생성자 이름

## 관계

- [CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)
- EthTrust Security Levels
  - [**[S] Use a Modern Compiler**](https://entethalliance.org/specs/ethtrust-sl/#req-1-compiler-060)
  - [**[Q] Code Linting**](https://entethalliance.org/specs/ethtrust-sl/#req-3-linted)

## 설명

생성자는 컨트랙트 생성 중에 한 번만 호출되는 특수 함수입니다. 종종 컨트랙트의 소유자를 설정하는 것과 같은 중요하고 특권적인 작업을 수행합니다. Solidity 버전 0.4.22 이전에는 생성자를 정의하는 유일한 방법은 이를 포함하는 컨트랙트 클래스와 동일한 이름으로 함수를 생성하는 것이었습니다. 생성자가 되도록 의도된 함수는 이름이 컨트랙트 이름과 정확히 일치하지 않으면 일반적인 호출 가능한 함수가 됩니다.
이 동작은 때때로 보안 문제로 이어지며, 특히 스마트 컨트랙트 코드가 다른 이름으로 재사용되지만 생성자 함수의 이름이 그에 따라 변경되지 않은 경우에 특히 그렇습니다.

## 해결방법

Solidity 버전 0.4.22는 생성자 정의를 더 명확하게 만드는 새로운 `constructor` 키워드를 도입합니다. 따라서 컨트랙트를 최신 버전의 Solidity 컴파일러로 업그레이드하고 새로운 생성자 선언으로 변경하는 것이 권장됩니다.

## 참고자료

- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)

## 샘플

### incorrect_constructor_name1.sol

```solidity
/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol
 * @author: Ben Perez
 * Modified by Gerhard Wagner
 */


pragma solidity 0.4.24;

contract Missing{
    address private owner;

    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }

    function missing()
        public
    {
        owner = msg.sender;
    }

    function () payable {}

    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }
}

```

### incorrect_constructor_name1_fixed.sol

```solidity
/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol
 * @author: Ben Perez
 * Modified by Gerhard Wagner
 */


pragma solidity ^0.4.24;

contract Missing{
    address private owner;

    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }

    constructor()
        public
    {
        owner = msg.sender;
    }

    function () payable {}

    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }
}

```

### incorrect_constructor_name2.sol

```solidity
/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol
 * @author: Ben Perez
 * Modified by Gerhard Wagner
 */

pragma solidity 0.4.24;

contract Missing{
    address private owner;

    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }

    function Constructor()
        public
    {
        owner = msg.sender;
    }

    function () payable {}

    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }

}

```

### incorrect_constructor_name2_fixed.sol

```solidity
/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol
 * @author: Ben Perez
 * Modified by Gerhard Wagner
 */

pragma solidity ^0.4.24;

contract Missing{
    address private owner;

    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }

    constructor()
        public
    {
        owner = msg.sender;
    }

    function () payable {}

    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }

}

```
