# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

불충분한 가스 그리핑

## 관계

- [CWE-691: Insufficient Control Flow Management](https://cwe.mitre.org/data/definitions/691.html)
- EEA EthTrust Security Levels:
  - [**[Q] Manage Gas Usage Increases**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-3-enough-gas)
  - [**[Q] Protect Gas Usage**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-3-protect-gas)

## 설명

불충분한 가스 그리핑 공격은 데이터를 받아들이고 이를 다른 컨트랙트의 서브 호출에서 사용하는 컨트랙트에서 수행될 수 있습니다. 서브 호출이 실패하면 전체 트랜잭션이 되돌려지거나 실행이 계속됩니다. 릴레이어 컨트랙트의 경우, 트랜잭션을 실행하는 사용자인 '전달자'는 트랜잭션을 실행하기에는 충분하지만 서브 호출이 성공하기에는 충분하지 않은 가스만 사용하여 효과적으로 트랜잭션을 검열할 수 있습니다.

## 해결방법

불충분한 가스 그리핑을 방지하기 위한 두 가지 옵션이 있습니다:

- 신뢰할 수 있는 사용자만 트랜잭션을 중계하도록 허용합니다.
- 전달자가 충분한 가스를 제공하도록 요구합니다.

## 참고자료

- [Consensys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/attacks/griefing/)
- [What does griefing mean?](https://ethereum.stackexchange.com/questions/62829/what-does-griefing-mean)
- [Griefing Attacks: Are they profitable for the attacker?](https://ethereum.stackexchange.com/questions/73261/griefing-attacks-are-they-profitable-for-the-attacker)

## 샘플

### relayer.sol

```solidity
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing
 * @author: ConsenSys Diligence
 * Modified by Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract Relayer {
    uint transactionId;

    struct Tx {
        bytes data;
        bool executed;
    }

    mapping (uint => Tx) transactions;

    function relay(Target target, bytes memory _data) public returns(bool) {
        // replay protection; do not call the same transaction twice
        require(transactions[transactionId].executed == false, 'same transaction twice');
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;

        (bool success, ) = address(target).call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

// Contract called by Relayer
contract Target {
    function execute(bytes memory _data) public {
        // Execute contract code
    }
}

```

### relayer_fixed.sol

```solidity
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing
 * @author: ConsenSys Diligence
 * Modified by Kaden Zipfel
 */

pragma solidity ^0.5.0;

contract Relayer {
    uint transactionId;

    struct Tx {
        bytes data;
        bool executed;
    }

    mapping (uint => Tx) transactions;

    function relay(Target target, bytes memory _data, uint _gasLimit) public {
        // replay protection; do not call the same transaction twice
        require(transactions[transactionId].executed == false, 'same transaction twice');
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;

        address(target).call(abi.encodeWithSignature("execute(bytes)", _data, _gasLimit));
    }
}

// Contract called by Relayer
contract Target {
    function execute(bytes memory _data, uint _gasLimit) public {
        require(gasleft() >= _gasLimit, 'not enough gas');
        // Execute contract code
    }
}

```
