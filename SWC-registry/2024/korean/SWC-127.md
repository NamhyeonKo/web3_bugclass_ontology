# 알림: 이 콘텐츠는 더 이상 적극적으로 유지되지 않습니다.

SWC 레지스트리의 내용은 2020년 이후 철저하게 업데이트되지 않았습니다. 불완전하고 오류가 포함되어 있으며 중요한 누락이 있을 수 있습니다.

보안 검토자를 위한 지침으로 작성된 현재 유지되는 스마트 컨트랙트 취약점에 대한 안내는
[EEA EthTrust Security Levels specification](https://entethalliance.org/specs/ethtrust-sl)을 참조하십시오. 최신 릴리스 버전과 함께 사양을 개발하는 그룹의 최신 작업을 나타내는
[Editor's draft](https://entethalliance.github.io/eta-registry/security-levels-spec.html)도 제공됩니다.

현재 유지되고 있는 개발자를 위한 보안 고려사항에 대한 일반적인 지침은
[Smart Contract Security Verification Standard (SCSVS)](https://github.com/ComposableSecurity/SCSVS)를 통해서도 제공됩니다.

# 제목

함수 타입 변수를 사용한 임의 점프

## 관계

- [CWE-695: Use of Low-Level Functionality](https://cwe.mitre.org/data/definitions/695.html)
- EEA EthTrust Security Levels:
  - [**[S] No `assembly {}`**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-1-no-assembly)
  - [**[M] Avoid Common `assembly {}` Attack Vectors**](https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-2-safe-assembly)

## 설명

Solidity는 함수 타입을 지원합니다. 즉, 함수 타입 변수에 일치하는 시그니처를 가진 함수에 대한 참조를 할당할 수 있습니다. 이러한 변수에 저장된 함수는 일반 함수처럼 호출할 수 있습니다.

문제는 사용자가 함수 타입 변수를 임의로 변경하여 임의의 코드 명령을 실행할 수 있을 때 발생합니다. Solidity는 포인터 연산을 지원하지 않으므로 이러한 변수를 임의의 값으로 변경하는 것은 불가능합니다. 그러나 개발자가 `mstore` 또는 할당 연산자와 같은 어셈블리 명령을 사용하는 경우, 최악의 시나리오에서는 공격자가 함수 타입 변수를 임의의 코드 명령으로 가리킬 수 있어 필요한 검증과 필요한 상태 변경을 위반할 수 있습니다.

## 해결방법

어셈블리 사용은 최소화되어야 합니다. 개발자는 사용자가 함수 타입 변수에 임의의 값을 할당하도록 허용해서는 안 됩니다.

## 참고자료

- [Solidity CTF](https://medium.com/authio/solidity-ctf-part-2-safe-execution-ad6ded20e042)
- [Solidity docs - Solidity Assembly](https://solidity.readthedocs.io/en/v0.4.25/assembly.html)
- [Solidity docs - Function Types](https://solidity.readthedocs.io/en/v0.4.25/types.html#function-types)

## 샘플

### FunctionTypes.sol

```solidity
/*
 * @source: https://gist.github.com/wadeAlexC/7a18de852693b3f890560ab6a211a2b8
 * @author: Alexander Wade
 */

pragma solidity ^0.4.25;

contract FunctionTypes {

    constructor() public payable { require(msg.value != 0); }

    function withdraw() private {
        require(msg.value == 0, 'dont send funds!');
        address(msg.sender).transfer(address(this).balance);
    }

    function frwd() internal
        { withdraw(); }

    struct Func { function () internal f; }

    function breakIt() public payable {
        require(msg.value != 0, 'send funds!');
        Func memory func;
        func.f = frwd;
        assembly { mstore(func, add(mload(func), callvalue)) }
        func.f();
    }
}

```
